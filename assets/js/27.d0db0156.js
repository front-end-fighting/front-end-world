(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{311:function(t,s,a){"use strict";a.r(s);var n=a(14),_=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("我们经常提到的 JavaScript，其实指的是 ECMAScript。ECMAScript 是形成 JavaScript 语言基础的脚本语言。而我们常说的 ES6/ES7，其实是一些 ECMAScript 新特性，主要是用来提升开发效率的语法糖。对于 Javascript，我们需要了解以下一些知识。")]),t._v(" "),s("h1",{attrs:{id:"_1-单线程的-javascript"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-单线程的-javascript"}},[t._v("#")]),t._v(" 1. 单线程的 Javascript")]),t._v(" "),s("p",[t._v("作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。如果 Javascript 是多线程，当页面更新内容的时候、用户又触发了交互，这时候线程间的同步问题会变得很复杂，为了避免复杂性，Javascript 被设计为单线程。")]),t._v(" "),s("p",[t._v("那么这样一个单线程的 Javascript，要如何高效地进行页面的交互和渲染处理呢？Javascript 只有一个线程，意味着任务需要一个接一个地进行，如果这时候我们有一个任务是等待用户输入，那在用户进行操作前，所有其他任务都会等待，页面处于假死状态，体验糟糕。因此，异步任务出现了。")]),t._v(" "),s("p",[t._v('在浏览器中，任务可以分为同步任务和异步任务两种。同步任务在主线程上排队执行，只有前一个任务执行完毕，才能执行后一个任务。异步任务进入"任务队列"的任务，当该任务完成后，"任务队列"通知主线程，该任务才会进入主线程排队执行。主线程会在空闲时获取任务队列中的队列执行，这个模型也被称为 Event Loop。')]),t._v(" "),s("p",[t._v("异步任务机制会导致一些前端容易踩的坑，常见的有"),s("code",[t._v("setTimeout")]),t._v("、"),s("code",[t._v("setInterval")]),t._v("的时间精确性。该类方法设置一个定时器，当定时器计时完成时需要执行回调函数，此时才把回调函数放入事件队列中。如果当回调函数放入队列时，假设队列中还有大量的事件没执行，此时就会造成任务执行时间不精确。")]),t._v(" "),s("p",[t._v("一般来说，可以使用系统时钟来补偿计时器不准确性。在每次回调任务结束的时候，根据最初的系统时间和该任务的执行时间进行差值比较，来修正后续的定时器时间。")]),t._v(" "),s("h1",{attrs:{id:"_2-原型和继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-原型和继承"}},[t._v("#")]),t._v(" 2. 原型和继承")]),t._v(" "),s("p",[t._v("Javascript 的原型和继承围绕着一点展开：几乎所有的对象都是"),s("code",[t._v("Object")]),t._v("的实例，"),s("code",[t._v("Object")]),t._v("位于原型链的顶端。")]),t._v(" "),s("p",[s("strong",[t._v("原型对象")])]),t._v(" "),s("p",[t._v("当谈到继承时，JavaScript 只有一种结构：对象。几乎所有 JavaScript 中的对象都是"),s("code",[t._v("Object")]),t._v("的实例，包括函数、数组、对象等。Javascript 中的对象之所以用途广泛，是因为它的值既可以是原始类型（"),s("code",[t._v("numver")]),t._v("、"),s("code",[t._v("string")]),t._v("、"),s("code",[t._v("boolean")]),t._v("、"),s("code",[t._v("null")]),t._v("、"),s("code",[t._v("undefined")]),t._v("、"),s("code",[t._v("bigint")]),t._v("和"),s("code",[t._v("symbol")]),t._v("），还可以是对象和函数。其中，函数也是一种特殊的对象，它同样拥有属性和值，除此之外还有"),s("code",[t._v("name")]),t._v("（函数名）和"),s("code",[t._v("code")]),t._v("（函数代码）两个隐藏属性，因此可被调用。")]),t._v(" "),s("p",[t._v("在一个对象中，属性的值同样可以为另外一个对象，因此我们可以通过这样的方式来实现继承：使用一个代表原型的属性，属性的值为被继承的对象，此时可以通过层层查找来得到原型链上的对象和属性。在 Javascript 中，该属性便是"),s("code",[t._v("__proto__")]),t._v("，被继承的对象即原型对象"),s("code",[t._v("prototype")]),t._v("。")]),t._v(" "),s("p",[t._v("创建一个对象包括了工厂模式、构造函数模式、原型模式等，可以使用以下方法：")]),t._v(" "),s("ul",[s("li",[t._v("使用语法结构，即定义一个数组、函数、对象等")]),t._v(" "),s("li",[t._v("使用构造器: "),s("code",[t._v("new XXX()")])]),t._v(" "),s("li",[t._v("使用"),s("code",[t._v("Object.create")])]),t._v(" "),s("li",[t._v("使用"),s("code",[t._v("class")]),t._v("关键字")])]),t._v(" "),s("p",[t._v("其中，最常见的便是使用构造函数来创建对象：")]),t._v(" "),s("p",[t._v("(1) 默认情况下，所有原型对象（"),s("code",[t._v("prototype")]),t._v("）自动获得一个"),s("code",[t._v("constructor")]),t._v("属性，指向与之关联的构造函数。")]),t._v(" "),s("p",[t._v("(2) 当我们创建对象时，Javascript 就会创建该构造函数的实例。")]),t._v(" "),s("p",[t._v("(3) 创建的实例通过将"),s("code",[t._v("__proto__")]),t._v("指向构造函数的原型对象（"),s("code",[t._v("prototype")]),t._v("），来继承该原型对象的所有属性和方法。")]),t._v(" "),s("p",[t._v("构造函数、原型和实例的关系：")]),t._v(" "),s("ul",[s("li",[t._v("每个原型对象（"),s("code",[t._v("prototype")]),t._v("）都拥有"),s("code",[t._v("constructor")]),t._v("属性，指向该原型对象的构造函数")]),t._v(" "),s("li",[t._v("使用构造函数可以创建对象，创建的对象称为实例对象")]),t._v(" "),s("li",[t._v("实例对象通过将"),s("code",[t._v("__proto__")]),t._v("属性指向原型对象（"),s("code",[t._v("prototype")]),t._v("），实现了该原型对象的继承")]),t._v(" "),s("li",[t._v("实例与构造函数原型之间有直接的关系，但与构造函数之间没有")])]),t._v(" "),s("p",[t._v("关于"),s("code",[t._v("__proto__")]),t._v("和"),s("code",[t._v("prototype")]),t._v("，很多时候我们容易搞混：")]),t._v(" "),s("ul",[s("li",[t._v("每个对象都有"),s("code",[t._v("__proto__")]),t._v("属性来标识自己所继承的原型对象，但只有函数才有"),s("code",[t._v("prototype")]),t._v("属性")]),t._v(" "),s("li",[t._v("通过"),s("code",[t._v("prototype")]),t._v("和"),s("code",[t._v("__proto__")]),t._v("，JavaScript 可以在两个对象之间创建一个关联，使得一个对象可以通过委托访问另一个对象的属性和函数")])]),t._v(" "),s("p",[s("strong",[t._v("原型链")])]),t._v(" "),s("p",[t._v("原型链是 Javascript 中主要的继承方式，可以通过原型继承多个引用类型的属性和方法。")]),t._v(" "),s("p",[t._v("我们知道，一个对象可通过"),s("code",[t._v("__proto__")]),t._v("访问原型对象上的属性和方法，而该原型同样也可通过"),s("code",[t._v("__proto__")]),t._v("访问它的原型对象，这样我们就在实例和原型之间构造了一条原型链。JavaScript 中的所有对象都来自"),s("code",[t._v("Object")]),t._v("，因此默认情况下，任何函数的原型属性"),s("code",[t._v("__proto__")]),t._v("都是"),s("code",[t._v("window.Object.prototype")]),t._v("。"),s("code",[t._v("prototype")]),t._v("原型对象同样会具有一个自己的原型，层层向上直到一个对象的原型为"),s("code",[t._v("null")]),t._v("。")]),t._v(" "),s("p",[t._v("关于原型链，我们需要知道：")]),t._v(" "),s("ul",[s("li",[t._v("当试图访问一个对象的属性时，会优先在该对象上搜寻。如果找不到，还会依次层层向上搜索该对象的原型对象、该对象的原型对象的原型对象等（套娃告警）")]),t._v(" "),s("li",[t._v("根据定义，"),s("code",[t._v("null")]),t._v("没有原型，并作为这个原型链中的最后一个环节")]),t._v(" "),s("li",[t._v("在"),s("code",[t._v("__proto__")]),t._v("的整个原型链被查看之后，浏览器才会认为该属性不存在，并给出属性值为"),s("code",[t._v("undefined")]),t._v("的结论")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 任何函数的原型属性 __proto__ 都是 Object.prototype")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Object.getPrototypeOf() 方法返回指定对象的原型")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 我们能看到，null 作为原型链中最后一个环节")]),t._v("\nObject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getPrototypeOf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n")])])]),s("p",[t._v("我们来看个具体的例子：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 让我们假设我们有一个对象 o, 其有自己的属性 a 和 b：")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" o "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("a")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("b")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// o 的原型 o.__proto__有属性 b 和 c：")]),t._v("\no"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__ "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("b")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("c")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 最后, o.__proto__.__proto__ 是 null.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这就是原型链的末尾，即 null，")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 根据定义，null 没有__proto__.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 综上，整个原型链如下:")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("a")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("b")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("b")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("c")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当我们在获取属性值的时候，就会触发原型链的查找：")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// o.a => 1")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// o.b => 2")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// o.c => o.__proto__.c => 4")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// o.c => o.__proto__.d => o.__proto__.__proto__ == null => undefined")]),t._v("\n")])])]),s("p",[t._v("属性的查找会带来性能问题：")]),t._v(" "),s("ul",[s("li",[t._v("在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要")]),t._v(" "),s("li",[t._v("试图访问不存在的属性时，会遍历整个原型链")])]),t._v(" "),s("p",[s("strong",[t._v("继承")])]),t._v(" "),s("p",[t._v("前面我们提到，在 Javascript 中原型链是主要的继承方式。总体上，Javascript 中实现继承的方式包括：")]),t._v(" "),s("ul",[s("li",[t._v("原型链继承：把构造函数的原型赋值为另一个类型的实例")]),t._v(" "),s("li",[t._v("盗用构造函数(经典继承)：在子类构造函数中调用父类构造函数")]),t._v(" "),s("li",[t._v("组合继承：通过原型链继承共享的属性和方法，通过构造函数继承实例属性")]),t._v(" "),s("li",[t._v("原型式继承：将传入的对象作为创建的对象的原型，本质上是对给定对象执行浅复制")]),t._v(" "),s("li",[t._v("寄生式继承：基于一个对象创建一个新对象，增强新对象后返回新对象")]),t._v(" "),s("li",[t._v("寄生组合式继承")])]),t._v(" "),s("p",[t._v("其中，原型链继承方式中引用类型的属性被所有实例共享，无法做到实例私有；盗用构造函数方式可以实现实例属性私有，但要求类型只能通过构造函数来定义；组合继承融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式，它长这样：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Parent")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 私有属性，不共享")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 需要复用、共享的方法定义在父类原型上")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Parent")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("speak")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Child")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Parent")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将子类的 __proto__ 指向父类原型")]),t._v("\nChild"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__ "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Parent")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h1",{attrs:{id:"_3-函数执行上下文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-函数执行上下文"}},[t._v("#")]),t._v(" 3. 函数执行上下文")]),t._v(" "),s("p",[t._v("Javascript 运行过程主要分成三个阶段：")]),t._v(" "),s("p",[t._v("(1) 语法分析阶段：分析代码是否有语法错误（SyntaxError），如果有语法错误将会在控制台报错，并终止执行。")]),t._v(" "),s("p",[t._v("(2) 编译阶段。每进入一个不同的运行环境时都会：")]),t._v(" "),s("ul",[s("li",[t._v("创建一个新的执行上下文（Execution Context）")]),t._v(" "),s("li",[t._v("创建一个新的词法环境（Lexical Environment），即作用域")])]),t._v(" "),s("p",[t._v("(3) 执行阶段。Javascript 在运行过程中会产生一个调用栈，调用栈遵循 LIFO（先进后出，后进先出）原则：")]),t._v(" "),s("ul",[s("li",[t._v("将步骤 (2) 中创建的执行上下文压入执行栈，并成为正在运行的执行上下文")]),t._v(" "),s("li",[t._v("执行代码")]),t._v(" "),s("li",[t._v("在代码执行结束后，将其弹出执行栈")])]),t._v(" "),s("p",[s("strong",[t._v("Javascript 运行环境")])]),t._v(" "),s("p",[t._v("Javascript 运行环境包括全局环境、函数环境和"),s("code",[t._v("eval")]),t._v("。")]),t._v(" "),s("p",[t._v("第一次载入 Javascript 代码时，会创建一个全局环境。当函数被调用时，则进入该函数的运行环境。不同的函数运行环境不一样，即使是同一个函数，在被多次调用时也会创建多个不同的函数环境。")]),t._v(" "),s("p",[t._v("不同的运行环境中，变量和函数可访问的其他数据范围不同，各种的行为也有所区别。每进入一个不同的运行环境时，Javascript 都会创建一个新的执行上下文，该过程包括：建立作用域链（Scope Chain）、创建变量对象（VO，Variable Object）以及确定 this 的指向。")]),t._v(" "),s("p",[s("strong",[t._v("创建变量对象")])]),t._v(" "),s("p",[t._v("每个上下文都有一个关联的变量对象，这个上下文中定义的所有变量和函数都存在于这个对象上。在浏览器中，全局环境中的变量对象是"),s("code",[t._v("window")]),t._v("对象，所有的全局变量和函数都是作为"),s("code",[t._v("window")]),t._v("对象的属性和方法创建的。相对应的，在 Node 中则是"),s("code",[t._v("global")]),t._v("对象。")]),t._v(" "),s("p",[t._v("创建变量对象过程将会创建"),s("code",[t._v("arguments")]),t._v("对象（仅函数环境下），同时会检查当前上下文的函数声明和变量声明：")]),t._v(" "),s("ul",[s("li",[t._v("对于变量声明，给变量分配内存，初始化为"),s("code",[t._v("undefined")]),t._v("（定义声明和赋值声明分开，执行阶段才执行赋值语句）")]),t._v(" "),s("li",[t._v("对于函数声明，会在内存里创建函数对象，并且直接初始化为该函数对象")])]),t._v(" "),s("p",[t._v("这也是我们常说的变量提升和函数提升，其中函数声明提升优先于变量声明。变量提升容易带来在预期外被覆盖掉的问题，同时还可能导致本应该被销毁的变量没有被销毁等情况，因此 ES6 中引入了"),s("code",[t._v("let")]),t._v("和"),s("code",[t._v("const")]),t._v("关键字，从而使 Javascript 也拥有了块级作用域。")]),t._v(" "),s("p",[t._v("当代码进入执行阶段后，我们在编译阶段创建的变量对象（VO）中变量属性会进行赋值，变量对象会转为活动对象（Active Object，简称 AO），此时活动对象才可被访问。这便是 VO -> AO 的过程，本质上变量对象和活动对象为一个对象，但在编译阶段该对象值仍为"),s("code",[t._v("undefined")]),t._v("，且处于不可访问的状态。")]),t._v(" "),s("p",[s("strong",[t._v("this")])]),t._v(" "),s("p",[t._v("Javascript 中"),s("code",[t._v("this")]),t._v("指针代表的是执行当前代码的对象的所有者，可简单理解为"),s("code",[t._v("this")]),t._v("永远指向最后调用它的那个对象。")]),t._v(" "),s("p",[t._v("根据 JavaScript 中函数的调用方式不同，"),s("code",[t._v("this")]),t._v("分为以下情况：")]),t._v(" "),s("ul",[s("li",[t._v("在全局执行环境中（在任何函数体外部），"),s("code",[t._v("this")]),t._v("指向全局对象（在浏览器中为 "),s("code",[t._v("window")]),t._v("）")]),t._v(" "),s("li",[t._v("在函数内部，"),s("code",[t._v("this")]),t._v("的值取决于函数被调用的方式\n"),s("ul",[s("li",[t._v("函数作为对象的方法被调用，"),s("code",[t._v("this")]),t._v("指向调用这个方法的对象")]),t._v(" "),s("li",[t._v("函数用作构造函数时（使用"),s("code",[t._v("new")]),t._v("关键字），它的"),s("code",[t._v("this")]),t._v("被绑定到正在构造的新对象")]),t._v(" "),s("li",[t._v("在类的构造函数中，"),s("code",[t._v("this")]),t._v("是一个常规对象，类中所有非静态的方法都会被添加到"),s("code",[t._v("this")]),t._v("的原型中")])])]),t._v(" "),s("li",[t._v("在箭头函数中，"),s("code",[t._v("this")]),t._v("执行它被创建时的环境")]),t._v(" "),s("li",[t._v("使用"),s("code",[t._v("apply")]),t._v("、"),s("code",[t._v("call")]),t._v("、"),s("code",[t._v("bind")]),t._v("等方式调用：根据 API 不同，可切换函数执行的上下文环境，即"),s("code",[t._v("this")]),t._v("绑定的对象")])]),t._v(" "),s("h1",{attrs:{id:"_4-作用域和闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-作用域和闭包"}},[t._v("#")]),t._v(" 4. 作用域和闭包")]),t._v(" "),s("p",[t._v("我们常说的作用域即当前的执行上下文，在 ES5 后我们使用 Lexical Environment（词法环境）替代作用域来描述该执行上下文。词法环境由两个成员组成：环境记录（Environment Record）和和外部词法环境引用（Outer Lexical Environment，简称 Outer）。")]),t._v(" "),s("p",[t._v("每个词法环境的 Outer 记录了外层词法环境的引用，当在自身词法环境记录无法寻找到某个变量时，可以根据 Outer 向外层寻找。在最外层的全局词法环境中，Outer 为"),s("code",[t._v("null")]),t._v("。")]),t._v(" "),s("p",[t._v("当代码在一个环境中执行时，会通过 Outer 创建变量对象的一个作用域链，来保证对执行环境有权访问的变量和函数的有序访问。每个 JavaScript 执行环境都有一个和它关联在一起的作用域链，这个作用域链是一个对象列表或对象链。在函数执行过程中，变量的解析是沿着作用域链一级一级搜索的过程：")]),t._v(" "),s("ul",[s("li",[t._v("从第一个对象开始，逐级向后回溯，直到找到同名变量为止")]),t._v(" "),s("li",[t._v("找到后不再继续遍历，找不到就报错")]),t._v(" "),s("li",[t._v("当函数执行结束之后，执行期上下文将被销毁（作用域链和激活对象均被销毁）")])]),t._v(" "),s("p",[t._v("作用域链使得我们在函数内部可以直接读取外部以及全局变量，闭包使得我们可以从外部读取局部变量。")]),t._v(" "),s("p",[t._v("由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量。我们看下面的例子：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("alert")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//undefined")]),t._v("\n")])])]),s("p",[t._v("在全局环境下无法访问函数 B 内的变量，这是因为全局函数的作用域链里，不含有函数 B 内的作用域。现在如果我们想要访问内部函数的变量，可以这样做：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("C")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("alert")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//2")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("C")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//2")]),t._v("\n")])])]),s("p",[t._v("此处，A 变成一个闭包了。闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。闭包的常见用途包括：")]),t._v(" "),s("ul",[s("li",[t._v("用于从外部读取其他函数内部变量的函数")]),t._v(" "),s("li",[t._v("可以使用闭包来模拟私有方法")]),t._v(" "),s("li",[t._v("让这些变量的值始终保持在内存中（涉及垃圾回收机制，可能导致内存泄露问题）")])]),t._v(" "),s("h1",{attrs:{id:"_5-事件循环机制-event-loop"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-事件循环机制-event-loop"}},[t._v("#")]),t._v(" 5. 事件循环机制（Event Loop）")]),t._v(" "),s("p",[t._v("JavaScript 有一个基于事件循环的并发模型，称为事件循环（Event Loop）。前面我们提到异步任务的存在，Event Loop 的设计解决了异步任务的同步问题。")]),t._v(" "),s("p",[t._v("要理解 Javascript 的事件循环设计，需要先了解执行栈和任务队列。")]),t._v(" "),s("p",[s("strong",[t._v("执行栈")])]),t._v(" "),s("p",[t._v("函数执行过程会产生一个调用栈，调用栈可理解为一个存储函数调用的栈结构，遵循先进后出的原则：")]),t._v(" "),s("ul",[s("li",[t._v("每调用一个函数，该函数会被添加进调用栈，并开始执行")]),t._v(" "),s("li",[t._v("如果正在调用栈中执行的 A 函数还调用了 B 函数，那么 B 函数也将会被添加进调用栈")]),t._v(" "),s("li",[t._v("一旦 B 函数被调用，便会立即执行")]),t._v(" "),s("li",[t._v("当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码")])]),t._v(" "),s("p",[t._v("由此可见，该函数调用栈栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。在不考虑全局执行上下文时，我们可以理解为刚开始的时候调用栈是空的，每当有函数被调用，相应的执行上下文都会被添加到调用栈中。执行完函数中相关代码后，该执行上下文又会自动被调用栈移除，最后调用栈又回到了空的状态（不考虑全局执行上下文）。")]),t._v(" "),s("p",[t._v("由于栈的容量是有限制的，因此当我们没有合理调用函数的时候，可能会导致爆栈异常。")]),t._v(" "),s("p",[s("strong",[t._v("任务队列")])]),t._v(" "),s("p",[t._v("JavaScript 运行时会包含一个待处理的任务队列，每一个任务都关联着一个用以处理这个任务的回调函数。")]),t._v(" "),s("p",[t._v("任务队列则遵循先进先出的原则，处理过程如下：")]),t._v(" "),s("ul",[s("li",[t._v("运行时会从最先进入队列的任务开始处理队列中的任务")]),t._v(" "),s("li",[t._v("被处理的任务会被移出队列，并作为输入参数来调用与之关联的函数，此时会产生一个函数执行栈")]),t._v(" "),s("li",[t._v("函数会一直处理到执行栈再次为空，然后事件循环将会处理队列中的下一个任务")])]),t._v(" "),s("p",[t._v("在掌握了 Javascript 的单线程设计，以及同步任务、异步任务、执行栈和任务队列这些概念之后，我们来学习下 Event Loop 机制。")]),t._v(" "),s("p",[s("strong",[t._v("浏览器的 Event Loop")])]),t._v(" "),s("p",[t._v("在浏览器里，每当一个被监听的事件发生时，事件监听器绑定的相关任务就会被添加进任务队列。通过事件产生的任务是异步任务，常见的事件任务包括：")]),t._v(" "),s("ul",[s("li",[t._v("用户交互事件产生的事件任务，比如 DOM 操作")]),t._v(" "),s("li",[t._v("计时器产生的事件任务，比如"),s("code",[t._v("setTimeout")])]),t._v(" "),s("li",[t._v("异步请求产生的事件任务，比如 HTTP 请求")])]),t._v(" "),s("p",[t._v("Javascript 的运行过程，可以借用一张经典的图来描述：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://zhuanlan-1255459943.cos.ap-guangzhou.myqcloud.com/5/5-3.png",alt:""}})]),t._v(" "),s("p",[t._v("如图，主线程运行的时候，会产生堆（heap）和栈（stack），其中堆为内存、栈为函数调用栈。我们能看到，Event Loop 负责执行代码、收集和处理事件以及执行队列中的子任务，具体包括：")]),t._v(" "),s("ul",[s("li",[t._v("Javascript 有一个主线程和执行栈，所有的任务都会被放到调用栈等待主线程执行")]),t._v(" "),s("li",[t._v("同步任务会被放在调用栈中，按照顺序等待主线程依次执行")]),t._v(" "),s("li",[t._v("主线程之外存在一个任务队列，所有任务在主线程中以执行栈的方式运行")]),t._v(" "),s("li",[t._v("同步任务都在主线程上执行，栈中代码在执行的时候会调用 Web API，此时会产生一些异步任务")]),t._v(" "),s("li",[t._v("异步任务会在有了结果（比如被监听的事件发生时）后，将注册的回调函数放入任务队列中")]),t._v(" "),s("li",[t._v("执行栈中任务执行完毕后，此时主线程处于空闲状态，会从任务队列中获取任务进行处理")])]),t._v(" "),s("p",[t._v("上述过程会不断重复，这就是 JavaScript 的运行机制，称为事件循环机制（Event Loop）。")]),t._v(" "),s("p",[s("strong",[t._v("Node.js 中的 Event Loop")])]),t._v(" "),s("p",[t._v("除了浏览器，Node.js 中同样存在 Event Loop。我们知道 Javascript 是单线程的，Event Loop 使 Node.js 可以通过将操作转移到系统内核中来执行非阻塞 I/O 操作。")]),t._v(" "),s("p",[t._v("Node.js 中的事件循环执行过程为：")]),t._v(" "),s("p",[t._v("(1) 当 Node.js 启动时将初始化事件循环，处理提供的输入脚本。")]),t._v(" "),s("p",[t._v("(2) 提供的输入脚本可以进行异步 API 调用，然后开始处理事件循环。")]),t._v(" "),s("p",[t._v("(3) 在事件循环的每次运行之间，Node.js 会检查它是否正在等待任何异步 I/O 或计时器，如果没有，则将其干净地关闭。")]),t._v(" "),s("p",[t._v("与浏览器不一样，Node.js 中事件循环分成不同的阶段：")]),t._v(" "),s("ul",[s("li",[t._v("timers：此阶段由"),s("code",[t._v("setTimeout()")]),t._v("和安排的回调"),s("code",[t._v("setInterval()")]),t._v("执行")]),t._v(" "),s("li",[t._v("pending callbacks：执行推迟到下一个循环迭代的 I/O 回调")]),t._v(" "),s("li",[t._v("idle/prepare：仅在 Node.js 内部使用")]),t._v(" "),s("li",[t._v("poll：检索新的 I/O 事件，执行与 I/O 相关的回调，节点将在此处阻塞")]),t._v(" "),s("li",[t._v("check："),s("code",[t._v("setImmediate()")]),t._v("在这里调用回调")]),t._v(" "),s("li",[t._v("close callbacks：一些关闭回调，例如"),s("code",[t._v("socket.on('close', ...)")])])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("   ┌───────────────────────────┐\n┌─>│           timers          │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │\n│  └─────────────┬─────────────┘      ┌───────────────┐\n│  ┌─────────────┴─────────────┐      │   incoming:   │\n│  │           poll            │<─────┤               |\n│  └─────────────┬─────────────┘      │   data, etc.  │\n│  ┌─────────────┴─────────────┐      └───────────────┘\n│  │           check           │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │\n   └───────────────────────────┘\n")])])]),s("p",[t._v("由于事件循环阶段划分不一致，Node.js 和浏览器在对宏任务和微任务的处理上也不一样。")]),t._v(" "),s("p",[s("strong",[t._v("宏任务和微任务")])]),t._v(" "),s("p",[t._v("事件循环中的异步任务队列有两种：宏任务（MacroTask）和微任务（MicroTask）队列：")]),t._v(" "),s("ul",[s("li",[t._v("宏任务：包括 script 全部代码、"),s("code",[t._v("setTimeout")]),t._v("、"),s("code",[t._v("setInterval")]),t._v("、"),s("code",[t._v("setImmediate")]),t._v("（Node.js）、"),s("code",[t._v("requestAnimationFrame")]),t._v("（浏览器）、I/O 操作、UI 渲染（浏览器）")]),t._v(" "),s("li",[t._v("微任务：包括"),s("code",[t._v("process.nextTick")]),t._v("（Node.js）、"),s("code",[t._v("Promise")]),t._v("、"),s("code",[t._v("MutationObserver")])])]),t._v(" "),s("p",[t._v("在浏览器中，异步任务队列的执行过程如下：")]),t._v(" "),s("p",[t._v("(1) 宏任务队列一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务。")]),t._v(" "),s("p",[t._v("(2) 微任务队列中所有的任务都会被依次取出来执行，直到微任务队列为空。")]),t._v(" "),s("p",[t._v("(3) 在执行完所有的微任务之后，执行下一个宏任务之前，浏览器会执行 UI 渲染操作、更新界面。")]),t._v(" "),s("p",[t._v("我们能看到，在浏览器中每个宏任务执行完成后，会执行微任务队列中的任务。而在 Node.js 中，事件循环分为 6 个阶段，微任务会在事件循环的各个阶段之间执行。也就是说，每当一个阶段执行完毕，就会去执行微任务队列的任务。")])])}),[],!1,null,null,null);s.default=_.exports}}]);